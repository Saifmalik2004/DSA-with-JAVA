# README.md: Orderly String Problem

## Problem Description

Given a string `str` and an integer `k`, find the lexicographically smallest string that can be obtained by rotating the string at most `k` times. A rotation involves moving the first character of the string to the end. If `k > 1`, any permutation of the string is allowed, as multiple rotations can simulate any permutation. Return the lexicographically smallest string possible.

### Key Details
- **Input**:
  - `str`: A string of lowercase English letters.
  - `k`: An integer representing the maximum number of rotations allowed.
- **Output**: The lexicographically smallest string obtainable.
- **Constraints**:
  - `1 <= str.length <= 10^5`
  - `1 <= k <= 10^5`
  - `str` consists of lowercase English letters.
- **Examples**:
  - Input: `str = "bac", k = 1`
    - Output: `"acb"`
    - Explanation: Possible rotations are `"bac"`, `"acb"`, `"cba"`. The lexicographically smallest is `"acb"`.
  - Input: `str = "cba", k = 2`
    - Output: `"abc"`
    - Explanation: Since `k > 1`, any permutation is possible, so sort the characters to get `"abc"`.
  - Input: `str = "a", k = 1`
    - Output: `"a"`
    - Explanation: Only one character, so no change is possible.

## Intuition

- **Case 1: `k == 1`**:
  - Only one rotation is allowed, so we need to try all possible rotations of the string and find the lexicographically smallest one.
  - A rotation of a string `str` at index `i` is `str[i:] + str[0:i]`.
  - Compare all rotations to find the smallest.
- **Case 2: `k > 1`**:
  - With multiple rotations, we can achieve any permutation of the string (since rotating multiple times can reorder characters arbitrarily, especially for strings longer than 2).
  - The lexicographically smallest string is obtained by sorting the characters of `str` in ascending order.

The solution handles these cases separately: for `k == 1`, it computes all rotations; for `k > 1`, it sorts the characters.

## Approach: Rotation for k == 1, Sorting for k > 1

### Steps:
1. **Check `k`**:
   - If `k == 1`:
     - Initialize `res` as the original string `str`.
     - For each index `i` from 1 to `str.length - 1`:
       - Compute the rotation: `str[i:] + str[0:i]` (substring from `i` to end, plus substring from start to `i-1`).
       - If the rotated string is lexicographically smaller than `res`, update `res`.
     - Return `res`.
   - If `k > 1`:
     - Convert `str` to a character array.
     - Sort the array in ascending order.
     - Convert the sorted array back to a string and return it.

### Java Code:
```java
import java.util.Arrays;

public class Sol {
    public static String orderly(String str, int k) {
        if (k == 1) {
            String res = str;
            for (int i = 1; i < str.length(); i++) {
                String temp = str.substring(i) + str.substring(0, i);
                if (res.compareTo(temp) > 0) {
                    res = temp;
                }
            }
            return res;
        }
        char ans[] = str.toCharArray();
        Arrays.sort(ans);
        return new String(ans);
    }
}
```

### Why It Works:
- **For `k == 1`**:
  - All possible rotations are generated by concatenating substrings.
  - The `compareTo` method ensures we keep the lexicographically smallest rotation.
  - This checks all possible starting points for the string after one rotation.
- **For `k > 1`**:
  - Multiple rotations can simulate any permutation (e.g., for a string of length `n`, `n` rotations can cycle through all positions, and with `k > 1`, we can rearrange characters arbitrarily).
  - Sorting the characters gives the lexicographically smallest permutation, as it arranges letters in ascending order.
- **Correctness**:
  - For `k == 1`, we explicitly check all rotations.
  - For `k > 1`, sorting is optimal because any permutation is achievable, and the smallest letters in order produce the smallest string.

### Time and Space Complexity:
- **Time Complexity**:
  - **For `k == 1`**:
    - Generating each rotation: `O(n)` (substring operations in Java are `O(n)` due to string creation).
    - Comparing strings: `O(n)` per comparison.
    - Total for `n` rotations: `O(n^2)`.
  - **For `k > 1`**:
    - Converting to char array: `O(n)`.
    - Sorting: `O(n log n)` using Arrays.sort.
    - Total: `O(n log n)`.
  - Overall: `O(n^2)` in the worst case (when `k == 1` and `n` is large).
- **Space Complexity**:
  - **For `k == 1`**: `O(n)` for storing the temporary rotation string and `res`.
  - **For `k > 1`**: `O(n)` for the character array and output string.
  - Overall: `O(n)`.

## Example Walkthrough
- **Input**: `str = "bac", k = 1`
  - Rotations:
    - `i = 0`: `"bac"` (original).
    - `i = 1`: `"acb" + "b" = "acb"`.
    - `i = 2`: `"cb" + "ba" = "cba"`.
  - Compare: `"bac"`, `"acb"`, `"cba"`. Smallest is `"acb"`.
  - Output: `"acb"`.
- **Input**: `str = "cba", k = 2`
  - Since `k > 1`, sort characters: `['c', 'b', 'a']` → `['a', 'b', 'c']`.
  - Output: `"abc"`.

## Edge Cases
- **Single Character**: `str = "a", k = 1` → `"a"` (no rotations change it).
- **Empty String**: Not applicable due to constraints (`1 <= str.length`).
- **k > 1 with Long String**: Sorting gives the smallest permutation (e.g., `"zxy"`, `k = 2` → `"xyz"`).
- **All Same Characters**: `str = "aaa", k = 1` → `"aaa"` (all rotations are identical).
- **Large `n`**: Efficient for `n <= 10^5`, especially for `k > 1` (`O(n log n)`).

## Testing
```java
public class Main {
    public static void main(String[] args) {
        System.out.println(Sol.orderly("bac", 1)); // Output: "acb"
        System.out.println(Sol.orderly("cba", 2)); // Output: "abc"
        System.out.println(Sol.orderly("a", 1)); // Output: "a"
        System.out.println(Sol.orderly("aaa", 1)); // Output: "aaa"
    }
}
```

## Alternative Approach: KMP for k == 1
For `k == 1`, we can use the Knuth-Morris-Pratt (KMP) algorithm to find the lexicographically smallest rotation more efficiently:
- Concatenate `str + str` and find the smallest substring of length `n` using KMP or a similar string algorithm.
- **Time Complexity**: `O(n)` with KMP.
- **Drawback**: More complex to implement, and `O(n^2)` is acceptable given constraints.
- **Why Not Preferred**: The current approach is simpler and sufficient for `n <= 10^5`.

## Why This Solution is Great
- **Simple**: Clear logic with two cases (`k == 1` vs. `k > 1`).
- **Efficient**: `O(n^2)` for `k == 1` and `O(n log n)` for `k > 1`, suitable for constraints.
- **Robust**: Handles all edge cases (single character, same characters, large `n`).
- **Readable**: Easy to understand with minimal code.